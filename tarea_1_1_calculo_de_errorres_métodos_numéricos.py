# -*- coding: utf-8 -*-
"""Tarea 1.1_Calculo de errorres_Métodos Numéricos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_5C48oYoKldLjkbSx8XiQZR7GgatnaaJ

**Ejercicio 1**
"""

#   Codigo que implementa un esquema numerico
#   para determinar la precision de una maquina

#   David Ezequiel Caballero González

import numpy as np

iteraciones = []
precisiones = []

epsilon = 1.0
iteracion = 0
while 1.0 + epsilon != 1.0:
     epsilon /= 2
     iteracion = iteracion + 1
     iteraciones.append(iteracion)
     precisiones.append(epsilon)
     print(f"Iteracion: {iteracion}, Precisión de máquina: {epsilon}")

plt.plot(iteraciones, precisiones, marker='d')
plt.xlabel('Iteración')
plt.ylabel('Precisión de máquina')
plt.title('Precisión de máquina vs. Iteración')
plt.grid(True)
plt.show()

"""**Ejercicio 2**"""

from logging import error
#   Codigo que implementa un esquema numerico
#   para determinar la aproximacion de Leibniz

#   David Ezequiel Caballero González

import numpy as np
import matplotlib.pyplot as plt

def leibniz_pi(n):
    return 4 * sum((-1)**k / (2*k + 1) for k in range(n))

true_pi = np.pi
N_values = [10, 100, 1000, 10000]
errors_abs = []
errors_rel = []
errors_cuad = []

for N in N_values:
    approx_pi = leibniz_pi(N)
    error_abs = abs(true_pi - approx_pi)
    error_rel = error_abs / true_pi
    error_cuad = error_abs**2
    errors_abs.append(error_abs)
    errors_rel.append(error_rel)
    errors_cuad.append(error_cuad)
    print(f"N={N}: Error absoluto={error_abs}, Error relativo={error_rel}, Error cuadrático={error_cuad}")

plt.figure()
plt.plot(N_values, errors_abs, label='Error absoluto', marker='o')
plt.plot(N_values, errors_rel, label='Error relativo', marker='s')
plt.plot(N_values, errors_cuad, label='Error cuadrático', marker='p')
plt.xscale('log')
plt.yscale('log')
plt.xlabel('N')
plt.ylabel('Error')
plt.legend()
plt.title('Errores en la aproximación de pi')
plt.show()

"""**Ejercicio 3**"""

#   Codigo que implementa el calculo de errores
#   en operaciones numericas

#   David Ezequiel Caballero González

def calcular_errores(x, y, valor_real):
    diferencia = x - y
    error_abs = abs(valor_real - diferencia)
    error_rel = error_abs / abs(valor_real)
    error_pct = error_rel * 100
    error_cuad = error_abs**2
    print(f"Diferencia: {diferencia}")
    print(f"Error absoluto: {error_abs}")
    print(f"Error relativo: {error_rel}")
    print(f"Error porcentual: {error_pct}%")
    print(f"Error cuadrático: {error_abs}")
    return error_abs, error_rel

valores = [(1.0000001, 1.0000000, 0.0000001), (1.000000000000001, 1.000000000000000, 0.000000000000001)]

for x, y, real in valores:
    print(f"\nPara x={x}, y={y}:")
    calcular_errores(x, y, real)